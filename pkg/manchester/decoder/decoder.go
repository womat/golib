// Package decoder provides functionality to decode Manchester-encoded data signals from events
// generated by a Raspberry Pi (using GPIO events). It performs clock synchronization and bit
// decoding asynchronously using Go's goroutines and channels, ensuring efficient handling of events
// and data streams.
//
// The decoding process is divided into two main phases:
//   1. **Clock Discovery**: The package calculates the bit timing (bit period and half-bit period)
//      by analyzing a series of event samples, ensuring that data decoding starts with the correct timing.
//
//   2. **Data Decoding**: Once clock synchronization is achieved, the decoder interprets the incoming
//      event edges (rising and falling) as bits (High or Low) according to the Manchester encoding scheme.
//      The decoder also handles timing tolerances to account for variations in signal timing, ensuring robustness
//      in real-world conditions.
//
// Key Features:
// - Asynchronous event handling using goroutines to keep the main process responsive.
// - Clock synchronization phase to determine the bit timing based on incoming event samples.
// - Robust bit decoding with tolerance handling to account for signal noise and timing deviations.
// - Graceful shutdown mechanism to properly close channels and wait for background tasks to finish.
//
// The decoder uses three primary channels:
//   - `C`: Sends decoded bits (High/Low).
//   - `eventC`: Receives events (rising and falling edges).
//   - `quit`: Signals the termination of the decoding process.

package decoder

import (
	"log/slog"
	"sort"
	"strconv"
	"sync"
	"time"
)

// Event represents a state change event (e.g., RisingEdge or FallingEdge).
type Event struct {
	Time time.Time // Time is the exact time when the edge event was detected.
	Edge int       // Edge indicates the type of state change (RisingEdge or FallingEdge).
}

// Bit represents a decoded bit (High or Low).
type Bit int

const (
	FallingEdge = 0 // FallingEdge indicates an active to inactive event (high to low).
	RisingEdge  = 1 // RisingEdge indicates an inactive event to an active event (low to high).

	Low     Bit = 0  // Low represents a low signal level.
	High    Bit = 1  // High represents a high signal level.
	Invalid     = -1 // Invalid event. Used for error handling or when an event doesn't match expected timing.
)
const (
	discoverClock = iota // State for discovering the clock frequency based on bit timing.
	decodeData           // State for decoding data after clock synchronization.

	clockEventSamples = 500 // clockEventSamples is the number of event samples used to calculate the clock frequency.
	bitTimeTolerance  = 25  // bitTimeTolerance is the timing tolerance for half and full bit timings.
)

// Decoder holds all relevant information and channels for the decoding process.
type Decoder struct {
	state int // state keeps track of where in the process we are (clock discovery vs. data decoding).

	clockEventSamples []time.Duration // clockEventSamples stores the event samples used to calculate the bit periods (helps in discovering the clock)

	lastTimestamp   time.Time // lastTimestamp tracks the time of the last received event for calculating event intervals.
	receivedHalfBit int       // receivedHalfBit tracks the current half-bit being received (first or second half).

	fullBitTime time.Duration // bitTime Represents the full bit period (time for one complete cycle of a bit).e.g. clock rate 50Hz (25bit/s) >> clock period 20ms
	halfBitTime time.Duration // halfBitTime represents the half-bit period (half of the full bit period, used for synchronization).

	fullBitTimeTolerance time.Duration // Tolerance for the full bit period.
	halfBitTimeTolerance time.Duration // Tolerance for the half-bit period.

	C      chan Bit       // C is the channel to send the decoded bit stream.
	eventC chan Event     // eventC is the channel to receive the line events (rising/falling edges)..
	stop   chan struct{}  // stop is the channel to stop the Decoder.
	wg     sync.WaitGroup // wg signals that Decoder is stopped and closed.
}

// New creates a new Decoder instance, initializing its channels and setting the initial state to clock discovery.
// The state machine is set up to discover the clock first before proceeding to data decoding.
// This approach avoids premature decoding and ensures proper synchronization.
func New(c chan Event) *Decoder {
	d := &Decoder{
		C:                 make(chan Bit, 100),
		eventC:            c,
		stop:              make(chan struct{}),
		wg:                sync.WaitGroup{},
		clockEventSamples: make([]time.Duration, 0, clockEventSamples),
		state:             discoverClock,
	}
	d.wg.Add(1)
	// Start the decoding process in a separate goroutine.
	go d.listenForEvents()
	return d
}

// listenForEvents listens for events and sends them to the eventHandler for processing.
// The reason we use a goroutine here is to ensure the main process can remain responsive
// while the event handling is performed asynchronously.
func (d *Decoder) listenForEvents() {
	slog.Info("discovering clock frequency started")

	defer d.wg.Done()

	for {
		select {
		case <-d.stop:
			return
		case evt, ok := <-d.eventC:
			if !ok {
				return // Exit if the buffer channel is closed
			}

			d.eventHandler(evt)
		}
	}
}

// Close stops the Decoder, closes channels, and waits for the goroutine to finish.
// Properly closing the channels and waiting for the goroutine ensures the decoder
func (d *Decoder) Close() error {
	close(d.stop)

	// Wait until the run() function completes, ensuring that the goroutine terminates properly.
	d.wg.Wait()

	close(d.C)
	return nil
}

// eventHandler decodes line events (edges) to a bit stream.
//   - discoverClock:
//     the clock frequency is discovered by analyzing the bit periods (measuring full bit periods)
//   - synchronizing:
//     synchronize to the clock (distinguish a bit edge from a mid-bit transition)
//   - decode line events:
//     High: falling edge while a full bit period
//     or a falling edge while the second half of a half bit period
//     Low:  rising edge while a full bit period
//     or a rising edge while the second half of a half bit period
//     decoding manchester code:  https://www.elektroniktutor.de/internet/codes.html
func (d *Decoder) eventHandler(event Event) {
	delta := event.Time.Sub(d.lastTimestamp)
	d.lastTimestamp = event.Time

	switch d.state {
	case discoverClock:
		slog.Debug("discovering clock frequency", "signal time", delta, "probe", len(d.clockEventSamples))
		d.clockEventSamples = append(d.clockEventSamples, delta)

		// Once enough samples are gathered, calculate the bit periods.
		if len(d.clockEventSamples) >= clockEventSamples {
			d.halfBitTime, d.fullBitTime = calcBitPeriods(d.clockEventSamples)
			d.halfBitTimeTolerance = d.halfBitTime * bitTimeTolerance / 100
			d.fullBitTimeTolerance = d.fullBitTime * bitTimeTolerance / 100
			d.clockEventSamples = nil
			d.state = decodeData
			d.receivedHalfBit = 0
			slog.Info("discovering clock frequency finished", "frequency", strconv.FormatFloat(1/d.fullBitTime.Seconds(), 'f', 2, 64))
			slog.Debug("Timing values",
				"halfBitTime", d.halfBitTime,
				"halfBitTimeTolerance", d.halfBitTimeTolerance,
				"bitTime", d.fullBitTime,
				"bitTimeTolerance", d.fullBitTimeTolerance)
		}

	case decodeData:
		if withinTolerance(delta, d.fullBitTime, d.fullBitTimeTolerance) {
			// full bit recognized >> send bit
			d.receivedHalfBit = 0
			d.C <- mapEdge(event.Edge)
			return
		}

		if withinTolerance(delta, d.halfBitTime, d.halfBitTimeTolerance) {
			if d.receivedHalfBit == 0 {
				// first half bit recognized >> wait for second half bit
				d.receivedHalfBit = 1
				return
			}

			// second half bit recognized >> send bit
			d.receivedHalfBit = 0
			d.C <- mapEdge(event.Edge)
			return
		}

		slog.Warn("invalid interval", "delta", delta)
		d.receivedHalfBit = 0
		d.C <- Invalid

	default:
		slog.Error("unknown state", "state", d.state)
		d.state = discoverClock
		d.C <- Invalid
	}
}

// calcBitPeriods calculates the Manchester bit periods (clock) from the event samples
// It uses statistical analysis (sorting and median calculation) to determine the bit timing.
func calcBitPeriods(samples []time.Duration) (time.Duration, time.Duration) {
	// Ensure that there are enough samples (at least half of eventSamples)
	if len(samples) < clockEventSamples/2 {
		return 0, 0
	}

	// Sort the samples to help identify the half-bit period (the first entry should be half-bit)
	sort.Slice(samples, func(i, j int) bool { return samples[i] < samples[j] })

	var halfBitPeriodMedian time.Duration
	var fullBitPeriodMedian time.Duration

	// Identify the median half-bit period and the corresponding full-bit period.
	// Start from sample index 30 to ensure there is enough data for accurate median calculation.
	for n := 30; n < len(samples); n++ {
		halfBitPeriodMedian = median(samples[:n-1])

		// If the sample is 150% of the half-bit period, it is a full-bit period
		if samples[n] > halfBitPeriodMedian+halfBitPeriodMedian/2 {
			fullBitPeriodMedian = median(samples[n:])
			break
		}
	}

	// Fallback: If no clear split was found, assume full bit is twice half bit
	if fullBitPeriodMedian == 0 {
		fullBitPeriodMedian = halfBitPeriodMedian * 2
	}

	return halfBitPeriodMedian, fullBitPeriodMedian
}

// median calculates the median of a sorted slice
// caution: the slice must be sorted
func median(durations []time.Duration) time.Duration {
	n := len(durations)
	if n == 0 {
		return 0
	}
	if n%2 == 1 {
		return durations[n/2] // Return the middle element for an odd-length slice.
	}
	// Return the average of the two middle elements for an even-length slice.
	return (durations[n/2-1] + durations[n/2]) / 2
}

// withinTolerance checks if a value is within a given tolerance range around a reference value.
// This function helps ensure that events are close enough to the expected timing values (half or full bit period).
func withinTolerance(value, reference, tolerance time.Duration) bool {
	return (value - reference).Abs() <= tolerance
}

// mapEdge maps the edge event to a Bit (High or Low).
func mapEdge(edge int) Bit {
	if edge == RisingEdge {
		return High
	}
	return Low
}
